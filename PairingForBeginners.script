#2-0-1-EoverQ.txt
```
clear;
Q:=Rationals();
Qext<alpha>:=ExtensionField<Q,x|x^2+2>;
E:=EllipticCurve([Q|0,-2]);
Eext:=E(Qext);
P:=E![3,5];
S:=Eext![0,alpha];
2*P;
3*P;
```
#2-0-2-E:F11.txt
```
clear;
q:=11;
Fq:=GF(q);
E:=EllipticCurve([Fq|4,3]);
#E;
Points(E);
PointsAtInfinity(E);
Fq2<i>:=ExtensionField<Fq,x|x^2+1>;
#E(Fq2);
P:=E(Fq2)![2,5*i];
Q:=E(Fq2)![2*i+10,7*i+2];
```
#2-1-10-JacobiQ.txt
```
q:=97;
Fq:=GF(q);
Poly<x>:=PolynomialRing(Fq);
a:=5; b:=5;
E:=EllipticCurve([Fq|a,b]);
theta:=Roots(x^3+a*x+b)[1][1];

epsilon:=-(3*theta^2+4*a)/16;
delta:=3*theta/4;

R<X,Y>:=PolynomialRing(Fq,2);
J<X,Y>:=Curve(AffineSpace(R),ideal<R|Y^2-(epsilon*X^4-2*delta*X^2+1)>);
JQ:=ProjectiveClosure(J);
IsIsomorphic(JQ,E);

P:=E![77,21];

toJ :=function(P,E,J)
x:=P[1]; y:=P[2];
return J![ (2*(x-34))/y , ((2*x+34)*(x-34)^2-y^2)/y^2];
end function;

```
#2-1-1-E:R.txt
```
clear;
R:=RealField();
Poly<x>:=PolynomialRing(R);
f:=x^3-2*x;
y:=x;
Roots(y^2-f);
E:=EllipticCurve(f);
P1:=E![-1,-1];
P2:=E![0,0];
P3:=E![2,2];
P1+P2;
P2+P3;
P1+P3;
P2+P2;
y:=-1/2*x-3/2;
Roots(y^2-f);
2*P1;
```
#2-1-2-E:F11+.txt
```
clear;
Fq:=GF(11);
Poly<x>:=PolynomialRing(Fq);
f:=x^3-2*x;
y:=x;
Roots(y^2-f);
E:=EllipticCurve(f);
P:=E![5,7]; Q:=E![8,10];
y:=x+2;
Roots(y^2-f);
P+Q;
```
#2-1-3-E:R-Proj.txt
```
clear;
R:=RealField();
E:=EllipticCurve([R|3,0]);
P:=E![3,6];
lambda:=Random(0,1000);
E![3*lambda, 6*lambda, lambda] eq P;
E![12,24,4] eq P;
E![3*Sqrt(2), 6*Sqrt(2),Sqrt(2)] eq P;
C:=ComplexField();
EC:=E( C);
EC![3*Sqrt(-1), 6*Sqrt(-1), Sqrt(-1)] eq P;
```
#2-1-4-E:F13-Proj.txt
```
clear;
Fq:=GF(13);
A2<x,y>:=AffineSpace(Fq,2);
Eaff:=Curve(A2,[y^2-(x^3+5)]);
Eproj:=ProjectiveClosure(Eaff);
E:=EllipticCurve([Fq|0,5]);
// IsIsomorphic(E,Eaff);
// generates error - must be projective
IsIsomorphic(E,Eproj);
#E;
```
#2-1-5-E:F41-Proj.txt
```
clear;
Fq:=GF(41);
E:=EllipticCurve([Fq|4,-1]);
P2<X,Y,Z>:=ProjectiveSpace(Fq,2);
Eproj:=Curve(P2,[Y^2*Z-(X^3+4*X*Z^2-Z^3)]);
IsIsomorphic(E,Eproj);

```
#2-1-6-EoverQpart2.txt
```
clear;
Q:=Rationals();
Qext<alpha>:=ExtensionField<Q,x|x^2+2>;
E:=EllipticCurve([Q|0,-2]);
Eext:=E(Qext);
P:=E![3,5];
S:=Eext![0,alpha];

DBL:=function(P);
xP:=P[1]; yP:=P[2];
lambda:=(3*xP^2)/(2*yP); //a=0 on E
nu:=yP-lambda*xP;
X:=lambda^2-2*xP;
Y:=-(lambda*X+nu);
return Parent(P)![X,Y];
end function;

ADD:=function(P,Q);
xP:=P[1]; yP:=P[2];
xQ:=Q[1]; yQ:=Q[2];
lambda:=(yQ-yP)/(xQ-xP);
nu:=yP-lambda*xP;
X:=lambda^2-xP-xQ;
Y:=-(lambda*X+nu);
return Parent(P)![X,Y];
end function;

2*P eq DBL(P);
Q:=DBL(P);
ADD(P,Q) eq (P+Q);
R:=P+Q;
3*P eq R;

#IntegerToSequence(Denominator((10*P)[2]),2);
#IntegerToSequence(Denominator((100*P)[2]),2);
#IntegerToSequence(Denominator((1000*P)[2]),2);

```
#2-1-7-E:F23.txt
```
clear;
Fq:=GF(23);
a:=5; b:=7;
E:=EllipticCurve([Fq|a,b]);
P:=E![2,5];
Q:=E![12,1];

DBL:=function(P);
xP:=P[1]; yP:=P[2];
lambda:=(3*xP^2+a)/(2*yP);
nu:=yP-lambda*xP;
X:=lambda^2-2*xP;
Y:=-(lambda*X+nu);
"lambda = ", lambda, "nu = ", nu;
return Parent(P)![X,Y];
end function;

ADD:=function(P,Q);
xP:=P[1]; yP:=P[2];
xQ:=Q[1]; yQ:=Q[2];
lambda:=(yQ-yP)/(xQ-xP);
nu:=yP-lambda*xP;
X:=lambda^2-xP-xQ;
Y:=-(lambda*X+nu);
"lambda = ", lambda, "nu = ", nu;
return Parent(P)![X,Y];
end function;

ADD(P,Q) eq (P+Q);
R:=P+Q;
DBL(P) eq (2*P);
S:=2*P;
```
#2-1-8-MulByM.txt
```
clear;

q:=1021;
Fq:=GF(q);
a:=-3; b:=-3;
E:=EllipticCurve([Fq|a,b]);
P:=E![379,1011];

m:=655;
IntegerToSequence(m,2);

DBL:=function(P);
xP:=P[1]; yP:=P[2];
lambda:=(3*xP^2+a)/(2*yP);
nu:=yP-lambda*xP;
X:=lambda^2-2*xP;
Y:=-(lambda*X+nu);
return Parent(P)![X,Y];
end function;

ADD:=function(P,Q);
xP:=P[1]; yP:=P[2];
xQ:=Q[1]; yQ:=Q[2];
lambda:=(yQ-yP)/(xQ-xP);
nu:=yP-lambda*xP;
X:=lambda^2-xP-xQ;
Y:=-(lambda*X+nu);
return Parent(P)![X,Y];
end function;

Scalar:=function(m,P);
B:=IntegerToSequence(m,2);
R:=P;
for i:=#B-1 to 1 by -1 do
R:=DBL(R);
if B[i] eq 1 then
R:=ADD(R,P);
end if;
end for;
return R;
end function;

Scalar(m,P) eq m*P;
m*P;

```
#2-1-9-ProjAdd.txt
```
clear;

PROJADD:=function(XP,YP,ZP,XQ,YQ,ZQ);

XR:=(XP*ZQ-XQ*ZP)*(ZP*ZQ*(YP*ZQ-YQ*ZP)^2-(XP*ZQ-XQ*ZP)^2*(XP*ZQ+XQ*ZP));
YR:=ZP*ZQ*(XQ*YP-XP*YQ)*(XP*ZQ-XQ*ZP)^2-(YP*ZQ-YQ*ZP)*((YP*ZQ-YQ*ZP)^2*ZP*ZQ-(XP*ZQ+XQ*ZP)*(XP*ZQ-XQ*ZP)^2);
ZR:=ZP*ZQ*(XP*ZQ-XQ*ZP)^3;

return XR,YR,ZR;

end function;

Fq:=GF(NextPrime(Random(0,2^10))); //Random Curve
a:=Random(Fq); b:=Random(Fq);
E:=EllipticCurve([Fq|a,b]);

P:=Random(E); Q:=Random(E);
XP:=P[1]; YP:=P[2]; ZP:=P[3];
XQ:=Q[1]; YQ:=Q[2]; ZQ:=Q[3];

XR,YR,ZR:=PROJADD(XP,YP,ZP,XQ,YQ,ZQ);
E![XR,YR,ZR];
```
#2-2-10-SchoofSmall.txt
```
clear;

//We just do l=3, since t=0 there

q:=13;
Fq:=GF(q);
a:=2; b:=1;
E:=EllipticCurve([Fq|2,1]);
Poly<x,y>:=PolynomialRing(Fq,2);
Exy:=y^2-(x^3+a*x+b);

l:=3;
psi3:=Evaluate(DivisionPolynomial(E,3),x);
I3:=Ideal([Exy,psi3]);
R3:=quo<Poly|I3>;

R3!(x^(q^2));
R3!x;
```
#2-2-11-GLV:GLS.txt
```
clear;

q:=1048589;
Fq:=GF(q);
E:=EllipticCurve([Fq|2,0]);
Factorization(#E);
r:=524053;
AllRoots(Fq!-1,2);
i:=38993;
AllRoots(GF(r)!-1,2);
lambda:=304425;

P:=E![609782,274272];

psi:=function(P,E);
return E![-P[1],i*P[2]];
end function;

psi(P,E)-lambda*P;

Q:=E![447259,319154];

m:=103803;

m1:=0;
m0:=m;

//an ad-hoc short vector solver
min:=Max(m0,m1);
mini:=min;
for m0:=1 to 1000 do
for m1:=1 to 1000 do
if (m0+m1*lambda) mod r eq m then
print m0,m1;
end if;
end for;
end for;


```
#2-2-1-Torsion.txt
```
clear;
Fq:=GF(101);
a:=1; b:=1;
E:=EllipticCurve([Fq|a,b]);
P:=E![47,12];
pts:=Points(E);
#E;
orders:={};
for i:=1 to #E do
Include(~orders,Order(pts[i]));
end for;
orders;
Order(P);
Order(35*P);
Order(5*P);
Order(105*P);

```
#2-2-2-ECDLP.txt
```
clear;

Fq:=GF(1021);
a:=905; b:=100;
E:=EllipticCurve([Fq|a,b]);
Factorization(#E);
P:=E![1006,416];
Q:=E![612,827];
P2:=(#E div 2)*P; P3:=(#E div 3)*P; P7:=(#E div 7)*P; P23:=(#E div 23)*P;
Q2:=(#E div 2)*Q; Q3:=(#E div 3)*Q; Q7:=(#E div 7)*Q; Q23:=(#E div 23)*Q;
k2:=1;
while k2*P2 ne Q2 do
k2+:=1;
end while;
k3:=1;
while k3*P3 ne Q3 do
k3+:=1;
end while;
k7:=1;
while k7*P7 ne Q7 do
k7+:=1;
end while;
k23:=1;
while k23*P23 ne Q23 do
k23+:=1;
end while;
k:=ChineseRemainderTheorem([k2,k3,k7,k23],[2,3,7,23]);
k*P eq Q;

```
#2-2-3-NIST.txt
```
clear;

q:=115792089210356248762697446949407573530086143415290314195533631308867097853951;

r:=115792089210356248762697446949407573529996955224135760342422259061068512044369;

b:=41058363725152142129326129780047268409114441015993725554835256314039467401291;

p:=2^256-2^224+2^192+2^96-1;
E:=EllipticCurve([GF( p)|-3,b]);

Gx:=0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296;
Gy:=0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5;
Gx:=GF( p)!Gx;
Gy:=GF( p)!Gy;
P:=E![Gx,Gy];

Hx:=53987601597021778433910548064987973235945515666715026302948657055639179420355;
Hy:=53690949263410447908824456005055253553237881490194075871737490561466076234637;

```
#2-2-4-Deuring.txt
```
clear;

q:=23;
Fq:=GF(q);

low:=q+1-Floor(2*Sqrt(q));
high:=q+1+Floor(2*Sqrt(q));
size:=high-low;

curves:=[];
orders:=[];

while #curves lt (size+1) do
a:=Random(Fq);
b:=Random(Fq);
if IsEllipticCurve([a,b]) then
E:=EllipticCurve([Fq|a,b]);
if #E notin orders then
curves:=Append(curves,[E]);
orders:=Append(orders,#E);
end if;
end if;
end while;

curves;
orders;
```
#2-2-5-Frobenius.txt
```
clear;

Fq:=GF(67);
Fq2<u>:=ExtensionField<Fq,x|x^2+1>;
Fq3<v>:=ExtensionField<Fq,x|x^3+2>;

E:=EllipticCurve([Fq|4,3]);
pi:=FrobeniusMap(E);
pi2:=FrobeniusMap(E,2);
pi3:=FrobeniusMap(E,3);

P1:=E![15,50];
P2:=E(Fq2)![2*u + 16, 30*u + 39];
P3:=E(Fq3)![15*v^2 + 4*v + 8 , 44*v^2 + 30*v + 21];

P1; pi(P1);

P2; pi(P2); pi2(P2);

P3; pi(P3); pi2(P3); pi3(P3);

```
#2-2-6-Endo1.txt
```
clear;

q:=19;
Fq:=GF(q);
a:=0; b:=5;
E:=EllipticCurve([Fq|a,b]);
P:=E![-1,2];
AllRoots(Fq!1,3);
zi3:=AllRoots(Fq!1,3)[2];
E![P[1]*zi3,P[2]];

clear;

q:=23;
Fq:=GF(q);
a:=0; b:=5;
Fq2<u>:=ExtensionField<Fq,x|x^2+1>;
E:=EllipticCurve([Fq|a,b]);
P:=E![-1,2];
AllRoots(Fq!1,3);
AllRoots(Fq2!1,3);
zi3:=AllRoots(Fq2!1,3)[2];
E(Fq2)![P[1]*zi3,P[2]];

#AutomorphismGroup(E);
```
#2-2-7-AutoRing.txt
```
clear;

Fq:=GF(17);
a:=10; b:=0;
E:=EllipticCurve([Fq|a,b]);
AllRoots(Fq!-1,2);
i:=AllRoots(Fq!-1,2)[1];
P:=Random(E);
while P eq PointsAtInfinity(E)[1] do
P:=Random(E);
end while;
P;
E![-P[1],i*P[2]];
AutomorphismGroup(E);

clear;

Fq:=GF(19);
a:=10; b:=0;
E:=EllipticCurve([Fq|a,b]);
AllRoots(Fq!-1,2);
Fq2<i>:=ExtensionField<Fq,x|x^2+1>;
AllRoots(Fq2!-1,2)[1];
P:=Random(E);
while P eq PointsAtInfinity(E)[1] do
P:=Random(E);
end while;
P;
E(Fq2)![-P[1],i*P[2]];
AutomorphismGroup(E);
AutomorphismGroup(BaseChange(E,Fq2));

```
#2-2-8-CharFrob.txt
```
clear;
q:=67;
Fq:=GF(q);
a:=4; b:=3;
E:=EllipticCurve([Fq|a,b]);
Fq2<u>:=ExtensionField<Fq,x|x^2+1>;
Fq3<v>:=ExtensionField<Fq,x|x^3+2>;
t:=TraceOfFrobenius(E);
P:=E![15,50];
pi:=FrobeniusMap(E);
pi(P) eq P;
pi(pi(P))-t*pi(P)+q*P;
P2:=E(Fq2)![2*u+16,30*u+39];
pi(pi(P2)) eq P2;
pi(pi(P2))-t*pi(P2)+q*P2;
P3:=E(Fq3)![19*v^2+49*v+8,20*v^2+66*v+21];
pi(pi(P3))-t*pi(P3)+q*P3;
```
#2-2-9-DivisionPoly.txt
```
clear;
Fq:=GF(101);
a:=1; b:=1;
E:=EllipticCurve([Fq|a,b]);
Poly<x>:=PolynomialRing(Fq);
psi2<x>:=DivisionPolynomial(E,2);
psi3<x>:=DivisionPolynomial(E,3);
psi5<x>:=DivisionPolynomial(E,5);
psi7<x>:=DivisionPolynomial(E,7);
psi11<x>:=DivisionPolynomial(E,11);

Roots(psi2);
Roots(psi3);
x1:=Roots(psi3)[1][1]; x2:=Roots(psi3)[2][1];
Points(E,x1);
Points(E,x2);
Roots(psi5);
x1:=Roots(psi5)[1][1]; x2:=Roots(psi5)[2][1];
Points(E,x1);
Points(E,x2);
Roots(psi7);
x1:=Roots(psi7)[1][1]; x2:=Roots(psi7)[2][1]; x3:=Roots(psi7)[3][1];
Points(E,x1);
Points(E,x2);
Points(E,x3);
```
#3-0-1-DivisorSuppSum.txt
```
clear;
q:=RandomPrime(50);
Fq:=GF(q);
E:=EllipticCurve([Fq|Random(Fq),Random(Fq)]);

P:=Random(E); Q:=Random(E); R:=Random(E); S:=Random(E);

D1:=2*Divisor(P)-3*Divisor(Q);
D2:=3*Divisor(Q)+Divisor(R)-Divisor(S);

Degree(D1);
Degree(D2);
Degree(D1+D2);

Support(D1);
Support(D2);
Support(D1+D2);

```
#3-0-2-DivChordTangent.txt
```
clear;
q:=RandomPrime(50);
Fq:=GF(q);
a:=Random(Fq); b:=Random(Fq);
E:=EllipticCurve([Fq|a,b]);
F<x,y>:=FunctionField(E);

DBL:=function(P);
xP:=P[1]; yP:=P[2];
lambda:=(3*xP^2+a)/(2*yP);
nu:=yP-lambda*xP;
return F!(y-(lambda*x+nu));
end function;

ADD:=function(P,Q);
xP:=P[1]; yP:=P[2];
xQ:=Q[1]; yQ:=Q[2];
lambda:=(yQ-yP)/(xQ-xP);
nu:=yP-lambda*xP;
return F!(y-(lambda*x+nu));
end function;

P:=Random(E); Q:=Random(E);

l:=DBL(P);
Support(Divisor(l));
2*P;
(-2*P);

l:=ADD(P,Q);
Support(Divisor(l));
P;
Q;
(-(P+Q));
```
#3-0-3-ProjDivs.txt
```
clear;
Fq:=GF(131);
a:=0; b:=5;
A2<x,y>:=AffineSpace(Fq,2);
Eaff:=Curve(A2,[y^2-(x^3+a*x+b)]);
P:=Eaff![2,12];
Q:=Eaff![67,56];
lambda:=(Q[2]-P[2])/(Q[1]-P[1]);
nu:=Q[2]-lambda*Q[1];
l:=Curve(A2,[y-(lambda*x+nu)]);
IntersectionPoints(Eaff,l);

P2<X,Y,Z>:=ProjectiveSpace(Fq,2);
E:=EllipticCurve([Fq|a,b]);
F<x,y>:=FunctionField(E);
l:=y-(lambda*x+nu);
D:=Divisor(l);
Support(D);
//or
Zeros(l);
Poles(l);
```
#3-0-4-DivQuotient.txt
```
clear;
q:=RandomPrime(50);
Fq:=GF(q);
a:=Random(Fq); b:=Random(Fq);
E:=EllipticCurve([Fq|a,b]);
F<x,y>:=FunctionField(E);

DBL:=function(P);
xP:=P[1]; yP:=P[2];
lambda:=(3*xP^2+a)/(2*yP);
nu:=yP-lambda*xP;
return F!(y-(lambda*x+nu));
end function;

ADD:=function(P,Q);
xP:=P[1]; yP:=P[2];
xQ:=Q[1]; yQ:=Q[2];
lambda:=(yQ-yP)/(xQ-xP);
nu:=yP-lambda*xP;
return F!(y-(lambda*x+nu));
end function;

P:=Random(E); Q:=Random(E); R:=Random(E);

l:=ADD(P,Q);
Support(Divisor(l));

ld:=DBL(R);
Support(Divisor(ld));

lquot:=l/ld;
Support(Divisor(lquot));



```
#3-1-1-Principal.txt
```
clear;
q:=103;
Fq:=GF(q);
a:=20; b:=20;
E:=EllipticCurve([Fq|a,b]);
F<x,y>:=FunctionField(E);

P:=E![26,20];
Q:=E![63,78];
R:=E![59,95];
S:=E![24,25];
T:=E![77,84];
U:=E![30,99];
O:=PointsAtInfinity(E)[1];

Degree(Divisor(S)+Divisor(T)-Divisor(P)) eq 0;

D:=Divisor(P)+Divisor(Q)-Divisor(R)-Divisor(S);
Degree(D);
P+Q-R-S eq PointsAtInfinity(E)[1];
IsPrincipal(D);

D:=Divisor(P)+Divisor(Q)-Divisor(R)-Divisor(T);
Degree(D);
P+Q-R-T eq PointsAtInfinity(E)[1];
IsPrincipal(D);
bool,f:=IsPrincipal(D);

D:=Divisor(P)+Divisor(Q)-Divisor(U);
Degree(D);
P+Q-U;
IsPrincipal(D);

D:=D-Divisor(O);
Degree(D);
IsPrincipal(D);
bool,g:=IsPrincipal(D);

Zeros(f);
Poles(f);
Zeros(g);
Poles(g);

```
#3-1-2-ClassGroup.txt
```
clear;
q:=61;
Fq:=GF(q);
a:=8; b:=1;
E:=EllipticCurve([Fq|a,b]);
F<x,y>:=FunctionField(E);

P:=E![57,24];
Q:=E![25,37];
R:=E![17,32];
S:=E![42,35];
O:=PointsAtInfinity(E)[1];

D1:=Divisor(P)+Divisor(Q)+Divisor(R);
D2:=4*Divisor(O)-Divisor(S);

IsLinearlyEquivalent(D1,D2);
bool,f:=IsLinearlyEquivalent(D1,D2);

Support(Divisor(f));

Degree(D1-D2);
Support(D1-D2);
P+Q+R+S-4*O;
```
#3-1-3-DivLines.txt
```
clear;
q:=RandomPrime(50);
Fq:=GF(q);
a:=Random(Fq); b:=Random(Fq);
E:=EllipticCurve([Fq|a,b]);
F<x,y>:=FunctionField(E);

DBL:=function(P);
xP:=P[1]; yP:=P[2];
lambda:=(3*xP^2+a)/(2*yP);
nu:=yP-lambda*xP;
x2P:=lambda^2-2*xP;
l:=F!(y-(lambda*x+nu));
v:=F!(x-x2P);
return l,v;
end function;

ADD:=function(P,Q);
xP:=P[1]; yP:=P[2];
xQ:=Q[1]; yQ:=Q[2];
lambda:=(yQ-yP)/(xQ-xP);
nu:=yP-lambda*xP;
xPQ:=lambda^2-xP-xQ;
l:=F!(y-(lambda*x+nu));
v:=F!(x-xPQ);
return l,v;
end function;

P:=Random(E); Q:=Random(E);
l,v:=ADD(P,Q);
Support(Divisor(l));
Support(Divisor(v));
```
#3-2-1-Reduction.txt
```
clear;
q:=RandomPrime(50);
Fq:=GF(q);
a:=Random(Fq); b:=Random(Fq);
E:=EllipticCurve([Fq|a,b]);
F<x,y>:=FunctionField(E);
O:=PointsAtInfinity(E)[1];

points:=[];
xcoords:=[];
ycoords:=[];

D:=Divisor(O)-Divisor(O);
for i:=1 to 11 do
Pi:=Random(E);
xcoords:=Append(xcoords,Pi[1]);
ycoords:=Append(ycoords,Pi[2]);
points:=Append(points,Pi);
D:=D+Divisor(Pi)-Divisor(O);
end for;

l:=y-Evaluate(Interpolation(xcoords,ycoords),x);
Support(Divisor(l));

Dd:=Divisor(l)-D;
Support(Dd); // Divisors not necessarily defined over Fq


```
#3-2-2-Genus2.txt
```
clear;
q:=RandomPrime(50);
Fq:=GF(q);
Poly<x>:=PolynomialRing(Fq);
f4:=Random(Fq); f3:=Random(Fq); f2:=Random(Fq); f1:=Random(Fq); f0:=Random(Fq);
f:=x^5+f4*x^4+f3*x^3+f2*x^2+f1*x+f0;
C2:=HyperellipticCurve(f);
F<x,y>:=FunctionField(C2);
O:=PointsAtInfinity(C2)[1];

P1:=Random(C2); P2:=Random(C2); P3:=Random(C2); P4:=Random(C2);
D:=Divisor(P1)+Divisor(P2)+Divisor(P3)+Divisor(P4)-4*Divisor(O);

l:=F!Interpolation([P1[1],P2[1],P3[1],P4[1]],[P1[2],P2[2],P3[2],P4[2]]);
l:=F!(y-l);
Support(Divisor(l));

```
#3-2-3-Genus3.txt
```
clear;
q:=RandomPrime(50);
Fq:=GF(q);
Poly<x>:=PolynomialRing(Fq);
f6:=Random(Fq); f5:=Random(Fq); f4:=Random(Fq); f3:=Random(Fq); f2:=Random(Fq); f1:=Random(Fq); f0:=Random(Fq);
f:=x^7;
for i:=6 to 0 by -1 do
f:=f+Random(Fq)*x^i;
end for;
C2:=HyperellipticCurve(f);
Genus(C2);
F<x,y>:=FunctionField(C2);
O:=PointsAtInfinity(C2)[1];

P1:=Random(C2); P2:=Random(C2); P3:=Random(C2); P4:=Random(C2); P5:=Random(C2); P6:=Random(C2);
D:=Divisor(P1)+Divisor(P2)+Divisor(P3)+Divisor(P4)+Divisor(P5)+Divisor(P6)-6*Divisor(O);

l:=F!y-F!Interpolation([P1[1],P2[1],P3[1],P4[1]],[P1[2],P2[2],P3[2],P4[2]]);
Support(Divisor(l));
```
#3-2-4-FunctionDivisor.txt
```
clear;
Fq:=GF(163);
a:=-1; b:=-2;
E:=EllipticCurve([Fq|a,b]);

P:=E![43,154];
Q:=E![46,38];
R:=E![12,35];
S:=E![5,66];

DP:=Divisor(P);
DQ:=Divisor(Q);

F<x,y>:=FunctionField(E);

lambda:=(3*P[1]^2+a)/(2*P[2]);
nu:=P[2]-lambda*P[1];
f2P:=y-(lambda*x+nu);

lambda:=(3*Q[1]^2+a)/(2*Q[2]);
nu:=Q[2]-lambda*Q[1];
f2Q:=y-(lambda*x+nu);

lambda:=(Q[2]-P[2])/(Q[1]-P[1]);
nu:=P[2]-lambda*P[1];
fPQ:=y-(lambda*x+nu);

Evaluate(fPQ,R)^2*Evaluate(fPQ,S);
Evaluate(f2P,R)^3/Evaluate(f2P,S)^3;

//Evaluate(f2Q,R)*Evaluate(f2Q,S)/Evaluate(f2Q,Identity(E))^2; // gives error... because...

Evaluate(f2Q,Identity(E))^2;
```
#3-3-1-WeilRecip1.txt
```
clear;

Fq:=GF(503);
a:=0; b:=1;
E:=EllipticCurve([Fq|a,b]);

P:=E![433,98];
Q:=E![127,258];
R:=E![339,199];
S:=E![124,42];
T:=E![147,443];

DP:=Divisor(P);
DQ:=Divisor(Q);

F<x,y>:=FunctionField(E);

lambda:=(3*P[1]^2+a)/(2*P[2]);
nu:=P[2]-lambda*P[1];
f2P:=y-(lambda*x+nu);

lambda:=(3*Q[1]^2+a)/(2*Q[2]);
nu:=Q[2]-lambda*Q[1];
f2Q:=y-(lambda*x+nu);

f:=f2P/f2Q;

g<x>:=Interpolation([R[1],S[1],T[1]],[R[2],S[2],T[2]]);
g:=y-g;

Proj<X,Y,Z>:=ProjectiveSpace(Fq,2);
INT:=Curve(P,[Y*Z-(252*X^2+374*X*Z+302*Z^2)]);
EC:=Curve(P,Y^2*Z-(X^3+a*X*Z^2+b*Z^3));

IntersectionPoints(INT,EC);
U:=E![413,369]; //The new point of intersection

Support(Divisor(f));
Support(Divisor(g));

Evaluate(f,R)*Evaluate(f,S)*Evaluate(f,T)*Evaluate(f,U)/(Evaluate(f,Identity(E)))^4;

Evaluate(g,P)^2*Evaluate(g,(-2*P))/(Evaluate(g,Q)^2*Evaluate(g,(-2*Q)));

```
#3-3-2-WeilRecip2.txt
```
clear;

Fq:=GF(RandomPrime(20));
a:=Random(Fq); b:=Random(Fq);
E:=EllipticCurve([Fq|a,b]);
F<x,y>:=FunctionField(E);
O:=PointsAtInfinity(E)[1];

DBL:=function(P);
xP:=P[1]; yP:=P[2];
lambda:=(3*xP^2+a)/(2*yP);
nu:=yP-lambda*xP;
return F!(y-(lambda*x+nu));
end function;

ADD:=function(P,Q);
xP:=P[1]; yP:=P[2];
xQ:=Q[1]; yQ:=Q[2];
lambda:=(yQ-yP)/(xQ-xP);
nu:=yP-lambda*xP;
return F!(y-(lambda*x+nu));
end function;

P:=Random(E);
R:=Random(E);
S:=Random(E);
T:=-(R+S);

l:=ADD(R,S);
ld:=DBL(P);

//ld(R)*ld(S)*ld(T)/ld(O)^3; error because..
ld(O);

U:=Random(E);
RU:=R+U;
SU:=S+U;
TU:=T+U;
ld(RU)*ld(SU)*ld(TU)/ld(U)^3;

```
#4-0-1-WeilPairing.txt
```
clear;

q:=7691;
Fq:=GF(q);
a:=0; b:=1;
E:=EllipticCurve([Fq|a,b]);
Factorization(#E);
P:=E![2693,4312];
Fq2<i>:=ExtensionField<Fq,x|x^2+1>;
E:=BaseChange(E,Fq2);
Factorization(#E);
P:=E!P;
Q:=E![633*i+6145,7372*i+109];
r:=641;
WeilPairing(P,Q,r);
WeilPairing(P,Q,r)^r;
a:=403; b:=135;
a*P;
b*Q;
WeilPairing(a*P,Q,r);
WeilPairing(a*P,Q,r) eq WeilPairing(P,Q,r)^a;
WeilPairing(P,b*Q,r);
WeilPairing(P,b*Q,r) eq WeilPairing(P,Q,r)^b;
WeilPairing(a*P,b*Q,r);
WeilPairing(a*P,b*Q,r) eq WeilPairing(P,Q,r)^(a*b);
```
#4-0-2-BilinearMap.txt
```
clear;

r:=RandomPrime(30);
R:=quo<RingOfIntegers()|r>; //Z_r
G1:=MultiplicativeGroup(R);
GT:=MultiplicativeGroup(R);
Rn1:=quo<RingOfIntegers()|r-1>;
G2:=AdditiveGroup(Rn1);
g1:=Random(G1);
g2:=Random(G1);
a1:=Random(0,r-1);
a2:=Random(0,r-1);
//Magma takes additive notation for G1, GT
function map(g,a);
return a*g;
end function;

map(g1,a1)+map(g2,a1) eq map(g1+g2,a1);
map(g1,a1)+map(g1,a2) eq map(g1,a1+a2);
map(g1+g2,a1+a2) eq map(g1,a1)+map(g1,a2)+map(g2,a1)+map(g2,a2);
```
#4-1-1-ThreeTorsionFlower.txt
```
clear;
q:=11;
Fq:=GF(q);
Fq2<i>:=ExtensionField<Fq,x|x^2+1>;
a:=0;
b:=4;
E:=EllipticCurve([Fq|a,b]);
fac:=Factorization(#E);
fac2:=Factorization(#E(Fq2));
points:=Points(E(Fq2));

TorsPts:={};

for i:=1 to #points do
if 3*points[i] eq Identity(E) then
Include(~TorsPts,points[i]);
end if;
end for;

function FlowerGenerator(TorsPts);
V:={};
S:=TorsPts;
petals:=Integers()!Sqrt(#S)+1;
ptsInPet:=petals-1;
T:={};

for i:=1 to petals do
S:=S diff V;
P:=Random(S);
while P[3] eq 0 do
P:=Random(S);
end while;
V:={j*P:j in [1..ptsInPet]};
Include(~T,V);
end for;
return T;
end function;

FlowerGenerator(TorsPts);

P:=E(Fq2)![9*i+7,i];
Q:=E(Fq2)![8,i];
R:=E(Fq2)![2*i+7,i];

pi:=FrobeniusMap(E);


```
#4-1-2-FiveTorsionFlower.txt
```
clear;
q:=31;
Fq:=GF(q);
a:=0; b:=13;
E:=EllipticCurve([Fq|a,b]);
Factorization(#E);
r:=5;

points:=Points(E);

TorsPts:={};

for i:=1 to #points do
if r*points[i] eq Identity(E) then
Include(~TorsPts,points[i]);
end if;
end for;

function FlowerGenerator(TorsPts);
V:={};
S:=TorsPts;
petals:=Integers()!Sqrt(#S)+1;
ptsInPet:=petals-1;
T:={};

for i:=1 to petals do
S:=S diff V;
P:=Random(S);
while P[3] eq 0 do
P:=Random(S);
end while;
V:={j*P:j in [1..ptsInPet]};
Include(~T,V);
end for;
return T;
end function;

FlowerGenerator(TorsPts);




```
#4-1-3-SevenTorsionFlower.txt
```
clear;
q:=11;
Fq:=GF(q);
a:=7; b:=2;
E:=EllipticCurve([Fq|a,b]);
Fq3<u>:=ExtensionField<Fq,x|x^3+x+4>;
r:=7;
//SetPowerPrinting(Fq3,false);
points:=Points(E(Fq3));

TorsPts:={};

for i:=1 to #points do
if r*points[i] eq Identity(E) then
Include(~TorsPts,points[i]);
end if;
end for;

function FlowerGenerator(TorsPts);
V:={};
S:=TorsPts;
petals:=Integers()!Sqrt(#S)+1;
ptsInPet:=petals-1;
T:={};

for i:=1 to petals do
S:=S diff V;
P:=Random(S);
while P[3] eq 0 do
P:=Random(S);
end while;
V:={j*P:j in [1..ptsInPet]};
Include(~T,V);
end for;
return T;
end function;

FlowerGenerator(TorsPts);

pi:=FrobeniusMap(E);

function TraceMap(P,pi);
return pi(pi(P))+pi(P)+P;
end function;

P:=E(Fq3)![u^481,u^1049];
TraceMap(P,pi);

Q:=E(Fq3)![u^423,u^840];
TraceMap(Q,pi);

R:=E(Fq3)![u^1011,u^1244];
TraceMap(R,pi);
```
#4-1-4-Supersingular1.txt
```
clear;
q:=59;
Fq:=GF(q);
a:=0; b:=1;
E:=EllipticCurve([Fq|a,b]);
IsSupersingular(E);
r:=5;
Fq2<i>:=ExtensionField<Fq,x|x^2+1>;
#E(Fq2);

points:=Points(E(Fq2));

TorsPts:={};

for i:=1 to #points do
if r*points[i] eq Identity(E) then
Include(~TorsPts,points[i]);
end if;
end for;

function FlowerGenerator(TorsPts);
V:={};
S:=TorsPts;
petals:=Integers()!Sqrt(#S)+1;
ptsInPet:=petals-1;
T:={};

for i:=1 to petals do
S:=S diff V;
P:=Random(S);
while P[3] eq 0 do
P:=Random(S);
end while;
V:={j*P:j in [1..ptsInPet]};
Include(~T,V);
end for;
return T;
end function;

FlowerGenerator(TorsPts);

zi3:=24*i + 29;
for i:=1 to 10 do
P:=Random(points);
P,E(Fq2)![P[1]*zi3,P[2]];
end for;


```
#4-1-5-Supersingular2.txt
```
clear;
q:=59;
Fq:=GF(q);
a:=1; b:=0;
E:=EllipticCurve([Fq|a,b]);
IsSupersingular(E);
r:=5;
Fq2<i>:=ExtensionField<Fq,x|x^2+1>;
#E(Fq2);

points:=Points(E(Fq2));

TorsPts:={};

for i:=1 to #points do
if r*points[i] eq Identity(E) then
Include(~TorsPts,points[i]);
end if;
end for;

function FlowerGenerator(TorsPts);
V:={};
S:=TorsPts;
petals:=Integers()!Sqrt(#S)+1;
ptsInPet:=petals-1;
T:={};

for i:=1 to petals do
S:=S diff V;
P:=Random(S);
while P[3] eq 0 do
P:=Random(S);
end while;
V:={j*P:j in [1..ptsInPet]};
Include(~T,V);
end for;
return T;
end function;

FlowerGenerator(TorsPts);

Dis:= function(P);
return E(Fq2)![-P[1],i*P[2]];
end function;

P:=E(Fq2)![31*i+51,34*i+49];
Dis(P);

```
#4-3-1-QuadraticTwist.txt
```
clear;

function FlowerGenerator(TorsPts);
V:={};
S:=TorsPts;
petals:=Integers()!Sqrt(#S)+1;
ptsInPet:=petals-1;
T:={};

for i:=1 to petals do
S:=S diff V;
P:=Random(S);
while P[3] eq 0 do
P:=Random(S);
end while;
V:={j*P:j in [1..ptsInPet]};
Include(~T,V);
end for;
return T;
end function;

q:=11;
Fq:=GF(q);
Fq2<i>:=ExtensionField<Fq,x|x^2+1>;
a:=0;
b:=4;
E:=EllipticCurve([Fq|a,b]);
E:=BaseChange(E,Fq2);
points:=Points(E);
Et:=EllipticCurve([Fq2|a,-b]);
pointsT:=Points(Et);

TorsPts:={};
for i:=1 to #points do
if 3*points[i] eq Identity(E) then
Include(~TorsPts,points[i]);
end if;
end for;

TorsPtsTwist:={};
for i:=1 to #pointsT do
if 3*pointsT[i] eq Identity(Et) then
Include(~TorsPtsTwist,pointsT[i]);
end if;
end for;

FlowerGenerator(TorsPts);
FlowerGenerator(TorsPtsTwist);

PsiInv:=function(P,Et);
return Et![-P[1],i*P[2]];
end function;

Psi:=function(Pt,E);
return E![-Pt[1],1/i*Pt[2]];
end function;

P:=Random(TorsPts);
while P eq PointsAtInfinity(E)[1] do
P:=Random(TorsPts);
end while;

P;
PsiInv(P,Et);
Psi(PsiInv(P,Et),E);


```
#4-3-2-Twist:unTwist.txt
```
clear;

function FlowerGenerator(TorsPts);
V:={};
S:=TorsPts;
petals:=Integers()!Sqrt(#S)+1;
ptsInPet:=petals-1;
T:={};

for i:=1 to petals do
S:=S diff V;
P:=Random(S);
while P[3] eq 0 do
P:=Random(S);
end while;
V:={j*P:j in [1..ptsInPet]};
Include(~T,V);
end for;
return T;
end function;

unTwist:=function(P,u,E);
return E![P[1]/u^2,P[2]/u^3];
end function;

Twist:=function(P,u,Et);
return Et![P[1]*u^2,P[2]*u^3];
end function;

q:=103;
Fq:=GF(q);
a:=0; b:=72;
E:=EllipticCurve([Fq|a,b]);
r:=7;
Fq6<u>:=ExtensionField<Fq,x|x^6+2>;
E:=BaseChange(E,Fq6);
Et:=EllipticCurve([Fq6|0,b*u^6]);
n:=#E;
h:=n div r^2;

TorsPts:={};
TorsPtsTwist:={};

while #TorsPts lt r^2 do
P:=Random(E);
hP:=h*P;
if hP notin TorsPts then
for i:=1 to 6 do
Include(~TorsPts,i*hP);
end for;
end if;
end while;
while #TorsPtsTwist lt r^2 do
P:=Random(Et);
hP:=h*P;
if hP notin TorsPtsTwist then
for i:=1 to 6 do
Include(~TorsPtsTwist,i*hP);
end for;
end if;
end while;

FlowerGenerator(TorsPts);
FlowerGenerator(TorsPtsTwist);

P:=Random(TorsPts);
P;
Twist(P,u,Et);
unTwist(Twist(P,u,Et),u,E);
```
#5-0-1-f5P.txt
```
clear;

q:=23;
Fq:=GF(q);
a:=17; b:=6;
E:=EllipticCurve([Fq|a,b]);
P:=E![10,7];
O:=PointsAtInfinity(E)[1];

F<x,y>:=FunctionField(E);

D1:=Divisor(P)-Divisor(O);
D2:=2*Divisor(P)-Divisor(2*P)-Divisor(O);
D3:=3*Divisor(P)-Divisor(3*P)-2*Divisor(O);
D4:=4*Divisor(P)-Divisor(4*P)-3*Divisor(O);
D5:=5*Divisor(P)-Divisor(5*P)-4*Divisor(O);

fDBL:=function(P);
lambda:=(3*P[1]^2+a)/(2*P[2]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
v:=F!(x-(lambda^2-2*P[1]));
return F!(l/v);
end function;

fADD:=function(P,Q);
lambda:=(Q[2]-P[2])/(Q[1]-P[1]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
v:=F!(x-(lambda^2-P[1]-Q[1])); //x3=lamda^2-x1-x2,P[1] is x1, Q[1] is x2.
return F!(l/v);
end function;

lPP:=fDBL(P);
lP2P:=fADD(P,2*P);
lP3P:=fADD(P,3*P);
//fP4P:=fADD(P,4*P); THIS IS DEFINED AS 1
lP4P:=(x-10);

f5P:=lPP*lP2P*lP3P*lP4P;
Support(Divisor(f5P));
```
#5-1-1-WeilPairing1.txt
```
clear;

q:=23;
Fq:=GF(q);
a:=-1; b:=0;
E:=EllipticCurve([Fq|a,b]);
P:=E![2,11];
Fq2<i>:=ExtensionField<Fq,x|x^2+1>;
r:=3;
E2:=BaseChange(E,Fq2);
O:=PointsAtInfinity(E2)[1];
pi:=FrobeniusMap(E2);

//Q:=(#E2 div r^2)*Random(E2);
//(pi(Q)-q*Q) eq PointsAtInfinity(E2)[1] and Order(Q) eq 3;

P:=E2!P;
Q:=E2![21,12*i];
R:=E2![17*i,2*i + 21];
S:=E2![10*i + 18,13*i + 13];

F<x,y>:=FunctionField(E2);

fDBL:=function(P);
lambda:=(3*P[1]^2+a)/(2*P[2]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
v:=F!(x-(lambda^2-2*P[1]));
return F!(l/v);
end function;

fADD:=function(P,Q);
lambda:=(Q[2]-P[2])/(Q[1]-P[1]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
v:=F!(x-(lambda^2-P[1]-P[2]));
return F!(l/v);
end function;

f3P:=fDBL(P)*(x-P[1]);
lPR:=fADD(P,R);
f3PR:=f3P/lPR^3;
f3Q:=fDBL(Q)*(x-Q[1]);
lQS:=fADD(Q,S);
f3QS:=f3Q/lQS^3;


f3PR(Q+S)*f3QS(R)/(f3PR(S)*f3QS(P+R));
WeilPairing(P,Q,r);
WeilPairing(2*P,Q,r);
WeilPairing(P,2*Q,r);

```
#5-2-1-QuotientGroupCosets.txt
```
clear;

q:=5;
Fq:=GF(q);
Fq2<i>:=ExtensionField<Fq,x|x^2+2>;
a:=0;
b:=-3;
E:=EllipticCurve([Fq|a,b]);
E2:=BaseChange(E,Fq2);
Factorization(#E);
Factorization(#E2);
IsSupersingular(E);

r:=3;
h:=#E2 div r^2;

points:=Points(E2);
rmap:=MultiplicationByMMap(E2,r);
ker:=Kernel(rmap);
iso:=IsogenyFromKernel(ker);

coset:={r*i: i in points};
coset:=[i: i in coset];
ALL:={i: i in coset};
coset;


while #ALL lt #E2 do
R:=Random(E2);
if (coset[1]+R) notin ALL then
cosetnew:={};
for i:=1 to #coset do
Include(~cosetnew,coset[i]+R);
Include(~ALL,coset[i]+R);
end for;
cosetnew;
end if;
end while;

TorsPts:={};

for i:=1 to #points do
if r*points[i] eq points[1] then
Include(~TorsPts,points[i]);
end if;
end for;

function FlowerGenerator(TorsPts);
V:={};
S:=TorsPts;
petals:=Integers()!Sqrt(#S)+1;
ptsInPet:=petals-1;
T:={};

for i:=1 to petals do
S:=S diff V;
P:=Random(S);
while P[3] eq 0 do
P:=Random(S);
end while;
V:={j*P:j in [1..ptsInPet]};
Include(~T,V);
end for;
return T;
end function;

FlowerGenerator(TorsPts);

```
#5-2-2-TatePairing.txt
```
clear;

q:=5;
Fq:=GF(q);
Fq2<i>:=ExtensionField<Fq,x|x^2+2>;
a:=0;
b:=-3;
E:=EllipticCurve([Fq|a,b]);
E:=BaseChange(E,Fq2);
O:=PointsAtInfinity(E)[1];
F<x,y>:=FunctionField(E);

r:=3;
h:=#E div r^2;

fDBL:=function(P);
lambda:=(3*P[1]^2+a)/(2*P[2]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
v:=F!(x-(lambda^2-2*P[1]));
return F!(l/v);
end function;

fADD:=function(P,Q);
lambda:=(Q[2]-P[2])/(Q[1]-P[1]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
v:=F!(x-(lambda^2-P[1]-P[2]));
return F!(l/v);
end function;

P:=E![3,2];
Q:=E![i+1,4*i+2];
R:=E![2*i,i+2];

f:=fDBL(P);
f:=f*(x-(2*P)[1]);
Support(Divisor(f));

DQ:=Divisor(Q+R)-Divisor(R);
IsLinearlyEquivalent(DQ,Divisor(Q)-Divisor(O));

//TatePairing(P,Q,r); Magma computes f(Q) directly

f(Q+R)/f(R);
f(2*Q+R)/f(R);

P2:=2*P;
ft:=fDBL(P2);
ft:=ft*(x-(2*P2)[1]);
Support(Divisor(ft));

ft(Q+R)/ft(R);

```
#5-2-3-ReducedTate.txt
```
clear;

q:=19;
Fq:=GF(q);
Fq2<i>:=ExtensionField<Fq,x|x^2+1>;
a:=14;
b:=3;
E:=EllipticCurve([Fq|a,b]);
Factorization(#E);
E:=BaseChange(E,Fq2);
Factorization(#E);
O:=PointsAtInfinity(E)[1];
F<x,y>:=FunctionField(E);

r:=5;
h:=#E div r^2;

P:=E![17,9];
Q:=E![16,16*i];

fDBL:=function(P);
lambda:=(3*P[1]^2+a)/(2*P[2]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
v:=F!(x-(lambda^2-2*P[1]));
return F!(l/v);
end function;

fADD:=function(P,Q);
lambda:=(Q[2]-P[2])/(Q[1]-P[1]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
v:=F!(x-(lambda^2-P[1]-P[2]));
return F!(l/v);
end function;

/*f:=fDBL(P);
f2:=fADD(P,2*P);
f3:=fADD(P,3*P);
f4:=(x-(4*P)[1]);
f(Q);
f(2*Q);
*/

TatePairing(P,Q,r);
TatePairing(P,Q,r)^4;
TatePairing(4*P,Q,r);
TatePairing(P,4*Q,r);
TatePairing(2*P,2*Q,r);

ReducedTatePairing(P,Q,r);
ReducedTatePairing(P,Q,r)^4;
ReducedTatePairing(4*P,Q,r);
ReducedTatePairing(P,4*Q,r);
ReducedTatePairing(2*P,2*Q,r);

(4*i+2)^r;

```
#5-3-1-TateWeilMiller.txt
```
clear;

q:=47;
Fq:=GF(q);
a:=21; b:=15;
E:=EllipticCurve([Fq|a,b]);
r:=17;
k:=4;
Fq4<u>:=ExtensionField<Fq,x|x^4-4*x^2+5>;

P:=E![30,3]; //P:=Random(E);
P:=(Order(P) div r)*P;
E:=BaseChange(E,Fq4);
P:=E!P;
Q:=E![5*u^3 + 37*u + 13,7*u^3 + 45*u^2 + 10*u + 7];//Q:=Random(E);
h:=#E div r^2;
Q:=h*Q;
pi:=FrobeniusMap(E);
O:=PointsAtInfinity(E)[1];

TraceMap:=function(Q,pi);
return pi(pi(pi(Q)))+pi(pi(Q))+pi(Q)+Q;
end function;

Q:=k*Q-TraceMap(Q,pi); // Anti-trace map
pi(Q)-q*Q; //check

F<x,y>:=FunctionField(E);

fDBL:=function(P);
lambda:=(3*P[1]^2+a)/(2*P[2]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
v:=F!(x-(lambda^2-2*P[1]));
return F!(l/v);
end function;

fADD:=function(P,Q);
lambda:=(Q[2]-P[2])/(Q[1]-P[1]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
v:=F!(x-(lambda^2-P[1]-P[2]));
return F!(l/v);
end function;

Miller:=function(P,Q,r);
Q2:=2*Q;
T:=P; f:=1;
rbits:=IntegerToSequence(r,2);
for i:=#rbits-1 to 2 by -1 do
fd:=fDBL(T);
T:=2*T;
f:=f^2*(fd(Q2)/fd(Q));
if rbits[i] eq 1 then
fa:=fADD(T,P);
T:=T+P;
f:=f*fa(Q2)/fa(Q);
end if;
end for;

fd:=fDBL(T);
T:=2*T;
f:=f^2*fd(Q2)/fd(Q);

fa:=x-P[1];
f:=f*fa(Q2)/fa(Q);

return f;
end function;

Tate:=function(P,Q,r);
return Miller(P,Q,r)^((q^k-1) div r);
end function;

Weil:=function(P,Q,r);
return Miller(P,Q,r)/Miller(Q,P,r);
end function;

```
#6-1-1-k=9curve.txt
```
clear;

x:=2^45+2^41+2^42+2^39+2^40;
r:=x^6-x^3+1;
q:=((x+1)^2*(x^6-x^3+1)) div 3-x^7;

while not IsPrime(q) or not IsPrime(r div 3) do
x:=x+3;
r:=x^6-x^3+1;
q:=((x+1)^2*(x^6-x^3+1)) div 3-x^7;
end while;

Fq:=GF(q);
r:=r div 3;

i:=1;
E:=EllipticCurve([Fq|0,i]);
while (#E mod r) ne 0 do
i+:=1;
E:=EllipticCurve([Fq|0,i]);
end while;

k:=9;
q;
r;

(q^k-1) mod r;
#IntegerToSequence(q^k,2);
#IntegerToSequence(q,2);
#IntegerToSequence(r,2);
```
#6-1-2-BNcurve.txt
```
clear;

x:=2^66+2^64+2^61;

q:=36*x^4+36*x^3+24*x^2+6*x+1;
r:=36*x^4+36*x^3+18*x^2+6*x+1;

while not IsPrime(q) or not IsPrime(r) do
x:=x+1;
q:=36*x^4+36*x^3+24*x^2+6*x+1;
r:=36*x^4+36*x^3+18*x^2+6*x+1;
end while;

#IntegerToSequence(q^12,2);
#IntegerToSequence(r,2);

q:=2875788016482373728402120498006552346737721998351309856542751926351376964733335173;
r:=2875788016482373728402120498006552346737668371977047909896314898406560560716472109;
Fq:=GF(q);

E:=EllipticCurve([Fq|0,2]);
#E mod r;
```
#6-2-1-BigSupersingularCurve.txt
```
clear;

r:=NextPrime(2^255);
/*
repeat 
	h:=12*Random(0,2^1365);
until IsPrime(h*r-1);
*/
q:=425708693169757088196017853607835113595127103859429924930531263283244403251872949802982860038531930965867890444658222153407204383584492024637762799391807569669124814253270947366226515064812665901907204494611177526596015257984009814596057160388672298355821309046798841446111721495601835913381835880170934319890420895521320439930666405003725309562669243847766834546592867695533445054256132471093279787853214492986394176521193456205570309658462204234557728373615304193316916440130004424612327;

h:=7352984059166010680233884359397606261756085731577338642439932150955701269321213454518655461605744774716085653794334630778258378102093226056054442119867814442317069039216036089944150404302324800183491822164688698749102601811545840191574820318422314186443197052492022843531933221704298886040697066968888299462985825068144680220650422353753735779923579696322625555138319604221119415603229681158045748797449440677656;

//IsPrime(r*h-1);
//q:=h*r-1;
Fq:=GF(q);
E1:=EllipticCurve([Fq|0,314159]);
E2:=EllipticCurve([Fq|265358,0]);

IsSupersingular(E1);
IsSupersingular(E2);
Fq2<i>:=ExtensionField<Fq,x|x^2+1>;

h*r*Random(E1);
h*r*Random(E2);

```
#6-3-1-MNTCurve.txt
```
clear;

x:=10;
q:=x^2+x+1;
t1:=-x;
t2:=x+1;

while not IsPrime(q) or not (IsPrime(q+1-t1) or IsPrime(q+1-t2)) do
x:=x+1;
q:=x^2+x+1;
t1:=-x;
t2:=x+1;
end while;

Fq:=GF(q);


if IsPrime(q+1-t1) then
print "t1";
Factorization(4*q-t1^2);
nE:=0;
while nE ne (q+1-t1) do
E:=EllipticCurve([Fq|Random(Fq),Random(Fq)]);
nE:=#E;
end while;
else
print "t2";
Factorization(4*q-t2^2);
nE:=0;
while nE ne (q+1-t2) do
E:=EllipticCurve([Fq|Random(Fq),Random(Fq)]);
nE:=#E;
end while;
end if;

E;

```
#6-3-2-BLSCurve.txt
```
clear;

x:=2^63+2;
x:=9223372036854782449;
q:=(x-1)^2*(x^8-x^4+1) div 3+x;
r:=(x^8-x^4+1);

while not IsPrime(q) or not IsPrime(r) do
x+:=3;
q:=(x-1)^2*(x^8-x^4+1) div 3+x;
r:=(x^8-x^4+1);
end while;

Fq:=GF(q);
i:=1;
E:=EllipticCurve([Fq|0,i]);

while #E mod r ne 0 do
i+:=1;
E:=EllipticCurve([Fq|0,i]);
end while;

k:=1;
#E mod r;
while (q^k-1) mod r ne 0 do
k+:=1;
end while;
k;
```
#6-3-3-BNCurve.txt
```
clear;

x:=Random(0,2^20);

q:=36*x^4+36*x^3+24*x^2+6*x+1;
r:=36*x^4+36*x^3+18*x^2+6*x+1;

while not IsPrime(q) or not IsPrime(r) do
x:=x+1;
q:=36*x^4+36*x^3+24*x^2+6*x+1;
r:=36*x^4+36*x^3+18*x^2+6*x+1;
end while;

Fq:=GF(q);

i:=1;
E:=EllipticCurve([Fq|0,i]);
while #E mod r ne 0 do
i:=i+1;
E:=EllipticCurve([Fq|0,i]);
end while;

k:=1;
while (q^k-1) mod r ne 0 do
k+:=1;
end while;
k;
E;
```
#6-3-4-KSSk16Curve.txt
```
clear;
//This one takes a while
x:=2^50+21;
r:=(x^8+48*x^4+625) div 61250;
q:=(x^10+2*x^9+5*x^8+48*x^6+152*x^5+240*x^4+625*x^2+2398*x+3125) div 980;

while not IsPrime(r) or not IsPrime(q) do
if x mod 70 eq 25 then
x+:=20;
else
x+:=50;
end if;
r:=(x^8+48*x^4+625) div 61250;
q:=(x^10+2*x^9+5*x^8+48*x^6+152*x^5+240*x^4+625*x^2+2398*x+3125) div 980;
end while;

Fq:=GF(q);
i:=1;
E:=EllipticCurve([Fq|i,0]);
while #E mod r ne 0 do
i:=i+1;
E:=EllipticCurve([Fq|i,0]);
end while;

E;
#IntegerToSequence(q^16,2);
#IntegerToSequence(q,2);
#IntegerToSequence(r,2);
```
#7-1-1-TateNotDivisor.txt
```
clear;

q:=47;
Fq:=GF(q);
a:=21; b:=15;
E:=EllipticCurve([Fq|a,b]);
r:=17;
k:=4;
Fq4<u>:=ExtensionField<Fq,x|x^4-4*x^2+5>;

P:=E![30,3]; //P:=Random(E);
P:=(Order(P) div r)*P;
E:=BaseChange(E,Fq4);
P:=E!P;
Q:=E![5*u^3 + 37*u + 13,7*u^3 + 45*u^2 + 10*u + 7];//Q:=Random(E);
h:=#E div r^2;
Q:=h*Q;
pi:=FrobeniusMap(E);
O:=PointsAtInfinity(E)[1];

TraceMap:=function(Q,pi);
return pi(pi(pi(Q)))+pi(pi(Q))+pi(Q)+Q;
end function;

Q:=k*Q-TraceMap(Q,pi); // Anti-trace map
pi(Q)-q*Q; //check

F<x,y>:=FunctionField(E);
fDBL:=function(P);
lambda:=(3*P[1]^2+a)/(2*P[2]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
v:=F!(x-(lambda^2-2*P[1]));
return l,v;
end function;

fADD:=function(P,Q);
lambda:=(Q[2]-P[2])/(Q[1]-P[1]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
v:=F!(x-(lambda^2-P[1]-P[2]));
return l,v;
end function;

Miller:=function(P,Q,r);
T:=P; f:=1;
rbits:=IntegerToSequence(r,2);
for i:=#rbits-1 to 2 by -1 do
l,v:=fDBL(T);
T:=2*T;
f:=f^2*l(Q)/v(Q);
"DBL";
f;
if rbits[i] eq 1 then
l,v:=fADD(T,P);
T:=T+P;
f:=f*l(Q)/v(Q);
"ADD";
f;
end if;
end for;
l,v:=fDBL(T);
T:=2*T;
f:=f^2*l(Q)/v(Q);
"DBL";
f;
l:=x-P[1];
f:=f*l(Q);
"ADD";
l(Q);
return f;
end function;

Tate:=function(P,Q,r);
return Miller(P,Q,r)^((q^k-1) div r);
end function;

Tate(P,Q,r);

```
#7-1-2-TateDenomElim.txt
```
clear;

q:=47;
Fq:=GF(q);
a:=21; b:=15;
E:=EllipticCurve([Fq|a,b]);
r:=17;
k:=4;
Fq4<u>:=ExtensionField<Fq,x|x^4-4*x^2+5>;

P:=E![30,3]; //P:=Random(E);
P:=(Order(P) div r)*P;
E:=BaseChange(E,Fq4);
P:=E!P;
Q:=E![5*u^3 + 37*u + 13,7*u^3 + 45*u^2 + 10*u + 7];//Q:=Random(E);
h:=#E div r^2;
Q:=h*Q;
pi:=FrobeniusMap(E);
O:=PointsAtInfinity(E)[1];

TraceMap:=function(Q,pi);
return pi(pi(pi(Q)))+pi(pi(Q))+pi(Q)+Q;
end function;

Q:=k*Q-TraceMap(Q,pi); // Anti-trace map
pi(Q)-q*Q; //check

F<x,y>:=FunctionField(E);
fDBL:=function(P);
lambda:=(3*P[1]^2+a)/(2*P[2]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
return l;
end function;

fADD:=function(P,Q);
lambda:=(Q[2]-P[2])/(Q[1]-P[1]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
return l;
end function;

Miller:=function(P,Q,r);
T:=P; f:=1;
rbits:=IntegerToSequence(r,2);
for i:=#rbits-1 to 2 by -1 do
l:=fDBL(T);
T:=2*T;
f:=f^2*l(Q);
"DBL";
f;
if rbits[i] eq 1 then
l:=fADD(T,P);
T:=T+P;
f:=f*l(Q);
"ADD";
f;
end if;
end for;

l:=fDBL(T);
T:=2*T;
f:=f^2*l(Q);
"DBL";
f;

l:=x-P[1];
f:=f*l(Q);
"ADD";
f;

return f;
end function;

Tate:=function(P,Q,r);
return Miller(P,Q,r)^((q^k-1) div r);
end function;

Tate(P,Q,r);

```
#7-2-1-ProjectiveLine.txt
```
clear;
q:=RandomPrime(20); //bits in prime
Fq:=GF(q);
a:=Random(Fq); b:=Random(Fq);
E:=EllipticCurve([Fq|a,b]);
P:=Random(E);
X:=P[1]; Y:=P[2]; Z:=P[3];

X3:=2*Y*Z*(9*X^4+6*X^2*a*Z^2+a^2*Z^4-8*X*Z*Y^2);
Y3:=-(27*X^6+27*X^4*a*Z^2+9*X^2*a^2*Z^4-36*X^3*Z*Y^2+a^3*Z^6-12*a*Z^3*X*Y^2+8*Y^4*Z^2);
Z3:=8*Y^3*Z^3;

lambda:=(1/2)*(3*X^2+Z^2)/(Y*Z);
nu:=-(1/2)*(3*X^3+X*Z^2-2*Y^2*Z)/(Y*Z^2);

LAMBDA:=Z*(3*X^2+Z^2);
NU:=-(3*X^3+X*Z^2-2*Y^2*Z);
CO:=2*Y*Z^2;

E![X3/Z3,Y3/Z3];

CO*(P[2])-LAMBDA*(P[1])-NU;
```
#7-3-1-Tower12Degree.txt
```
clear;

q:=97;
Fq:=GF(q);
beta:=5;
Fqk<T>:=ExtensionField<Fq,x|x^12-beta>;

Fq2<u>:=ExtensionField<Fq,x|x^2-beta>;
Fq6<v>:=ExtensionField<Fq2,x|x^3-u>;
Fq12<w>:=ExtensionField<Fq6,x|x^2-v>;

Random(Fq12);
```
#7-4-1-ScottsNSS.txt
```
clear;

x:=-1;
q:=36*x^4+36*x^3+24*x^2+6*x+1;
r:=36*x^4+36*x^3+18*x^2+6*x+1;

while not IsPrime(q) or not IsPrime(r) do
x:=x+1;
q:=36*x^4+36*x^3+24*x^2+6*x+1;
r:=36*x^4+36*x^3+18*x^2+6*x+1;
end while;

Fq:=GF(q);
b:=1;
E:=EllipticCurve([Fq|0,b]);
while #E mod r ne 0 do
b+:=1;
E:=EllipticCurve([Fq|0,b]);
end while;

#E mod r;
O:=PointsAtInfinity(E)[1];

p1:=AllRoots(Fq!1,3)[2];
p2:=AllRoots(Fq!1,3)[3];

phi1:=function(P);
return E![P[1]*p1,P[2]];
end function;

phi2:=function(P);
return E![P[1]*p2,P[2]];
end function;


for i:=1 to 1 do
P:=Random(E);
if P eq O then
P:=Random(E);
end if;
Log(P,phi1(P)),Log(P,phi2(P));
lambda1:=Log(P,phi1(P)); lambda2:=Log(P,phi2(P));
end for;

(lambda1^2+lambda1+1) mod r;
(lambda2^2+lambda2+1) mod r;

IntegerToSequence(lambda1,2);
IntegerToSequence(lambda2,2);
x;

```
#7-4-2-ateCompare.txt
```
clear;

q:=47;
Fq:=GF(q);
a:=21; b:=15;
E:=EllipticCurve([Fq|a,b]);
r:=17;
k:=4;
T:=TraceOfFrobenius(E)-1;
Fq4<u>:=ExtensionField<Fq,x|x^4-4*x^2+5>;


P:=E![30,3]; //P:=Random(E);
P:=(Order(P) div r)*P;
E:=BaseChange(E,Fq4);
P:=E!P;
Q:=E![5*u^3 + 37*u + 13,7*u^3 + 45*u^2 + 10*u + 7];//Q:=Random(E);
h:=#E div r^2;
Q:=h*Q;
pi:=FrobeniusMap(E);
O:=PointsAtInfinity(E)[1];


TraceMap:=function(Q,pi);
return pi(pi(pi(Q)))+pi(pi(Q))+pi(Q)+Q;
end function;

Q:=k*Q-TraceMap(Q,pi); // Anti-trace map
//pi(Q)-q*Q; //check

F<x,y>:=FunctionField(E);
fDBL:=function(P);
lambda:=(3*P[1]^2+a)/(2*P[2]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
return l;
end function;

fADD:=function(P,Q);
lambda:=(Q[2]-P[2])/(Q[1]-P[1]);
c:=P[2]-lambda*P[1];
l:=F!(y-(lambda*x+c));
return l;
end function;

Miller:=function(P,Q,r);
T:=P; f:=1;
rbits:=IntegerToSequence(r,2);
for i:=#rbits-1 to 1 by -1 do
l:=fDBL(T);
T:=2*T;
f:=f^2*l(Q);
f;
if rbits[i] eq 1 then
l:=fADD(T,P);
T:=T+P;
f:=f*l(Q);
end if;
end for;
f;
return f;
end function;

ate:=function(Q,P,T);
return Miller(Q,P,Abs(T))^((q^k-1) div r);
end function;

ate(Q,P,T);

```
#7-4-3-BNShortVector.txt
```
clear;

//This code was written by Paulo Barreto
//It was passed to me by Luis Dominguez Perez

function IsWeakPopov(pivot_index)
n := #pivot_index;
for k in [1..n-1] do
if pivot_index[k] eq 0 then
continue; // k not in carrier set
end if;
for l in [k+1..n] do
if pivot_index[l] eq 0 then
continue; // l not in carrier set
end if;
if pivot_index[k] eq pivot_index[l] then
return false;
end if;
end for;
end for;
return true;
end function;

function PivotIndex(M)
n := Nrows(M);
m := Ncols(M);
pivot_index := [0 : i in [1..n]];
for i in [1..n] do
// find rightmost element with maximal degree in the i-th row:
max_deg := -1; max_j := 0;
for j := m to 1 by -1 do
deg := Degree(M[i, j]);
if deg gt max_deg then
max_deg := deg; max_j := j;
end if;
end for;
pivot_index[i] := max_j;
end for;
return pivot_index;
end function;

function WeakPopov(M,x)
n := Nrows(M);
m := Ncols(M);
while true do
pivot_index := PivotIndex(M);
if IsWeakPopov(pivot_index) then
break;
end if;
// apply first kind transforms to force M into weak Popov form
for k in [1..n] do
if pivot_index[k] eq 0 then
continue; // k not in carrier set
end if;
D := Degree(M[k, pivot_index[k]]);
P := LeadingCoefficient(M[k, pivot_index[k]]);
for l in [1..n] do
if l eq k then
continue;
end if;
if Degree(M[l, pivot_index[k]]) ge D then
// apply simple transform of 2nd kind:
c := LeadingCoefficient(M[l, pivot_index[k]])/P;
e := Degree(M[l, pivot_index[k]]) - D;
M[l] -:= c*x^e*M[k];
break k; // only one transform!
end if;
end for;
end for;
end while;
return M;
end function;

function RelaxedWeakPopov(M,x)
n := Nrows(M);
m := Ncols(M);
for count in [1..1000] do // only way to ensure the algorithm will terminate
pivot_index := PivotIndex(M);
if IsWeakPopov(pivot_index) then
break;
end if;
// apply first kind transforms to force M into weak Popov form
for k in [1..n] do
if pivot_index[k] eq 0 then
continue; // k not in carrier set
end if;
D := Degree(M[k, pivot_index[k]]);
P := LeadingCoefficient(M[k, pivot_index[k]]);
for l in [1..n] do
if l eq k then
continue;
end if;
if Degree(M[l, pivot_index[k]]) ge D then
// apply simple transform of 2nd kind:
c := LeadingCoefficient(M[l, pivot_index[k]]);
if c mod P eq 0 then
c := LeadingCoefficient(M[l, pivot_index[k]]) div P;
e := Degree(M[l, pivot_index[k]]) - D;
M[l] -:= c*x^e*M[k];
break k; // only one transform!
end if;
end if;
end for;
end for;
end for;
return M;
end function;

ConstructM:=function(R,k,r,t,x)
m:=EulerPhi(k);
l:=[];
for i:=1 to m do
n:=[];
for j:=1 to m do
Append(~n,0);
end for;
Append(~l,n);
end for;
M:=Matrix(R,m,m,l);
M[1][1]:=r;
T:=t-1;
for i:=2 to m do
M[i][1]:=-T^(i-1);
M[i][i]:=1;
end for;
return M;
end function;

setOptimalPairing:=procedure(~p,~r,~t,~k,~Zx,~x,~z,~O,~pivot_index,~flag)

M:=ConstructM(Zx,k,r,t,x);
pivot_index := PivotIndex(M);

if BaseRing(Zx) eq Rationals() then
N := WeakPopov(M,x);
else
N := RelaxedWeakPopov(M,x);
end if;
pivot_index := PivotIndex(N);
flag:=IsWeakPopov(pivot_index);
if flag eq true then
O:=N;
end if;
end procedure;

Zx<x>:=PolynomialRing(Integers());

k:=12;
px:= 36*x^4 + 36*x^3 + 24*x^2 + 6*x + 1;
rx:= 36*x^4 + 36*x^3 + 18*x^2 + 6*x + 1;
tx:= 6*x^2+1;

setOptimalPairing(~px,~rx,~tx,~k,~Zx,~x,~z,~N,~pivot_index,~flag);
print N;
printf "The shortest vector is: %o", N[pivot_index];

```
#7-4-4-KSSShortVector.txt
```
clear;

//Use the functions from the previous example

Zx<x>:=PolynomialRing(Rationals());

k:=16;
px:= 1/980*( x^10+2*x^9+5*x^8+48*x^6+152*x^5+240*x^4+625*x^2+2398*x+3125 );
rx:= x^8+48*x^4+625;
tx:= 1/35*(2*x^5+41*x+35);

setOptimalPairing(~px,~rx,~tx,~k,~Zx,~x,~z,~N,~pivot_index,~flag);
print N;
printf "The shortest vector is: %o", N[pivot_index];

```
#7-4-5-BLSateIsOptimal.txt
```
clear;
k:=24;
Poly<x>:=PolynomialRing(Rationals());
p:= 1/3*(x-1)^2*(x^8-x^4+1)+x;
r:= x^8 - x^4 + 1;
t:= x+1;
Degree(r)/EulerPhi(k) eq Degree(t);
```
#7-5-1-BLShamming.txt
```
clear;

x:=258419657403767392;

q:=(x-1)^2*(x^8-x^4+1) div 3+x;
r:=(x^8-x^4+1);
Fq:=GF(q);
i:=1;
E:=EllipticCurve([Fq|0,i]);

while #E mod r ne 0 do
i+:=1;
E:=EllipticCurve([Fq|0,i]);
end while;

#E mod r;

x:=144115188109674496;

q:=(x-1)^2*(x^8-x^4+1) div 3+x;
r:=(x^8-x^4+1);
Fq:=GF(q);
i:=1;
E2:=EllipticCurve([Fq|0,i]);

while #E2 mod r ne 0 do
i+:=1;
E2:=EllipticCurve([Fq|0,i]);
end while;

#E2 mod r;

E,E2;

```
#7-6-1-FinalExp.txt
```
clear;

//Doubling and line function 
function Dbl(X1,Y1,Z1,xQ,yQ,u,v,w,z)

xQ:=3*xQ;

A:=X1^2; 
B:=Y1^2; 
C:=Z1^2; 
D:=2*C;
E:=2*D;
D:=2*E;
D:=D+E; 
D:=D*v; 
E:=X1+Y1; 
E:=E^2;
E:=E-A;
E:=E-B; 
F:=Y1+Z1; 
F:=F^2;
F:=F-B;
F:=F-C; 

L1:=D-B; 
L2:=xQ*A;
L3:=yQ*F;
L3:=-L3;

l := -L2*z^2+ L1 +L3*(u*w);

G:=2*D;
G:=G+D;
X3:=B-G;
X3:=E*X3;
E:=2*X3;
X3:=E+X3; 
E:=G^2;
E:=2*E;
E:=2*E; 
Y3:=B+G;
Y3:=Y3^2;
C:=2*Y3;
Y3:=C+Y3; 
Y3:=Y3-E; 
Z3:=B*F;
Z3:=2*Z3;
E:=2*Z3;
Z3:=2*E;
Z3:=Z3+E; 

return X3, Y3, Z3, l;

end function;

function Add(X1, Y1, Z1, X2, Y2, xQ, yQ,u,v,w,z) 

A:=Z1*X2; 
A:=X1-A; 
B:=Z1*Y2; 
B:=Y1-B; 
C:=X2*B;
D:=A*Y2;

L1:=C-D;
L2:=xQ*B;
L2:=-L2;
L3:=yQ*A; 

l:=L1+L3*(u*w)+L2*(-z^2); 

C:=A^2; 
X3:=C*X1; 
C:=A*C; 
D:=B^2; 
D:=D*Z1; 
D:=C+D; 
D:=D-X3; 
D:=D-X3; 
X3:=X3-D; 
B:=B*X3; 
Y3:=C*Y1;
Y3:=B-Y3; 
X3:=A*D; 
Z3:=Z1*C; 

return X3, Y3, Z3, l;

end function;

function MillerAte(P, Q, r,u,v,w,z)

x1 := P[1]; y1 := P[2]; z1:=P[3];
x2 := P[1]; y2 := P[2]; z2:=P[3];
xQ := Q[1]; yQ := Q[2]; 

f1 := 1; 
B := IntegerToSequence(r, 2);

for i:=#B-1 to 1 by -1 do
x1,y1,z1, line := Dbl(x1,y1,z1,xQ,yQ,u,v,w,z);
f1 := f1^2*line;
if B[i] eq 1 then
x1,y1,z1, line := Add(x1, y1,z1, x2, y2, xQ, yQ,u,v,w,z);
f1 := f1*line;
end if;
end for;

return f1;

end function;

unTwist := function(XT, YT,z)
Xu := XT/z^2;
Yu := YT/z^3;
return Xu, Yu;
end function;

Twist := function(XT, YT, z)
Xt := z^2*XT;
Yt := z^3*YT;
return Xt,Yt;
end function;

k:=24;
x0:= 9223372036854782449;
q:=(x0-1)^2*(x0^8-x0^4+1) div 3 + x0;
r:=(x0^8-x0^4+1);

Fq:=GF(q);
Fq2<u>:=ExtensionField<Fq,x|x^2+5>;
Fq4<v>:=ExtensionField<Fq2,x|x^2-u>;
Fq12<w>:=ExtensionField<Fq4,x|x^2-v>;
Fq24<z>:=ExtensionField<Fq12,x|x^3-w>;

b:= 1;
bt:= v;

E:=EllipticCurve([Fq|0,b]);
t:=TraceOfFrobenius(E);
T:=t-1;
Et:=EllipticCurve([Fq4|0,bt]);

P:=(#E div r)*Random(E);
Qt:=(#Et div r)*Random(Et);

xT,yT:=Twist(P[1],P[2],z);
Pt:=Et(Fq24)![xT,yT];

x,y:=unTwist(Qt[1],Qt[2],z);
Q:=E(Fq24)![x,y];

fact1:=Random(1,r);
fact2:=Random(1,r);

function HardPart(m,x,Fq);

m1:=m^x;
m2:=m1^x;
m1:=m1^2;
m1:=1/m1;
mu7:=m2*m1;
mu7:=mu7*m;
mu6:=mu7^x;
mu5:=mu6^x;
mu4:=mu5^x;
mu7i:=1/mu7;
mu3:=mu4^x;
mu3:=mu3*mu7i;
mu2:=mu3^x;
mu1:=mu2^x;
mu0:=mu1^x;
msqr:=m^2;
mu0:=mu0*msqr;
mu0:=mu0*m;

mu1:=Frobenius(mu1,Fq,1);
mu2:=Frobenius(mu2,Fq,2);
mu3:=Frobenius(mu3,Fq,3);
mu4:=Frobenius(mu4,Fq,4);
mu5:=Frobenius(mu5,Fq,5);
mu6:=Frobenius(mu6,Fq,6);
mu7:=Frobenius(mu7,Fq,7);

f:=mu0*mu1;
f:=f*mu2;
f:=f*mu3;
f:=f*mu4;
f:=f*mu5;
f:=f*mu6;
f:=f*mu7;

return f;

end function;

//All on twist

f1:=MillerAte(fact1*Qt,fact2*Pt,T,u,v,w,z);
f2:=MillerAte(fact2*Qt,fact1*Pt,T,u,v,w,z);

F1:=1/f1;
f1:=Frobenius(f1,Fq,12);
f1:=f1*F1;
F1:=Frobenius(f1,Fq,4);
f1:=f1*F1;

F2:=1/f2;
f2:=Frobenius(f2,Fq,12);
f2:=f2*F2;
F2:=Frobenius(f2,Fq,4);
f2:=f2*F2;

HardPart(f1,x0,Fq)-HardPart(f2,x0,Fq);


```
